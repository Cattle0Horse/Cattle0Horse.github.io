<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CattleHorse's Blog</title><link>https://cattle0horse.github.io/</link><description>Recent content on CattleHorse's Blog</description><generator>Hugo</generator><language>cn</language><lastBuildDate>Fri, 21 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://cattle0horse.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>2.信息的表示和处理</title><link>https://cattle0horse.github.io/posts/csapp/2-representation-and-processing-of-information/</link><pubDate>Fri, 21 Mar 2025 00:00:00 +0000</pubDate><guid>https://cattle0horse.github.io/posts/csapp/2-representation-and-processing-of-information/</guid><description>&lt;h2 id="2信息的表示和处理">2.信息的表示和处理&lt;/h2>
&lt;h3 id="信息的存储">信息的存储&lt;/h3>
&lt;p>通常情况下，程序将内存视为一个非常大的数组，数组的元素由一个个字节组成，每个字节都有唯一的数字表示，称为 Address(地址)，所有地址的集合就称为 Virtual Address Space(虚拟地址空间)&lt;/p>
&lt;p>&lt;img src="https://cattle0horse.github.io/posts/csapp/2-representation-and-processing-of-information/attachments/2.%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86-20250319221101744.png" alt="">
&lt;img src="https://cattle0horse.github.io/posts/csapp/2-representation-and-processing-of-information/attachments/2.%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86-20250319221439235.png" alt="">&lt;/p>
&lt;p>word size(字长): 决定了虚拟地址空间的大小，字长为 w 位的机器的虚拟地址空间 (程序使用连续的虚拟地址访问内存/磁盘) 的范围是 $0 \sim 2^{w} - 1$ （因为每一个 bit 位有 0 和 1 两种取值）&lt;/p>
&lt;ul>
&lt;li>32 位系统（如 x86）的虚拟地址空间最大为 4GB ( $2^{32}$ Byte)&lt;/li>
&lt;li>64 位系统（如 x86_64）：理论上可支持 16EB（ $2^{64}$ Byte），但实际操作系统通常不会完全使用。例如：
&lt;ul>
&lt;li>Linux 默认使用 48 位地址空间（256TB）。&lt;/li>
&lt;li>Windows 也类似，通常使用 47-48 位地址。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>大多数 64 位机器向后兼容，可以运行 32 位程序&lt;/p>
&lt;p>32 位程序与 64 位程序的区别是编译过程，而不是运行机器的类型&lt;/p>
&lt;p>在编译时可以通过编译选项指定生成 32 位的程序还是 64 位的程序
&lt;img src="https://cattle0horse.github.io/posts/csapp/2-representation-and-processing-of-information/attachments/2.%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86-20250319222358537.png" alt="">&lt;/p>
&lt;p>不同的数据类型可能占用不同的大小，同时对于不同位数的机器也有区别，很多数据类型都是占用了多个字节空间
&lt;img src="https://cattle0horse.github.io/posts/csapp/2-representation-and-processing-of-information/attachments/2.%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86-20250319222809671.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>对于需要存储的数据，我们需要知道「该数据的地址是什么」以及「数据在内存中是如何排布的」&lt;/p>&lt;/blockquote>
&lt;p>Byte Ordering(字节序)：数据在内存中的排列形式，有大端法与小端法两种方式，区别在于高位地址的位置&lt;/p>
&lt;ul>
&lt;li>Big Endian(大端法): 高位有效字节存储在低地址处 (优先读取最高有效字节)，更符合人类直觉，适用于网络传输和存储&lt;/li>
&lt;li>Little Endian(小端法): 低位有效字节存储在低地址处 (优先读取最低有效字节)，适合计算机内部处理，主流 CPU 采用&lt;/li>
&lt;/ul>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;strong>字节序&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>定义&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>示例（0x12345678）&lt;/strong>&lt;/th>
 &lt;th>&lt;strong>常见用途&lt;/strong>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>Big Endian&lt;/strong>&lt;/td>
 &lt;td>高位字节存低地址&lt;/td>
 &lt;td>&lt;code>12 34 56 78&lt;/code>&lt;/td>
 &lt;td>网络通信（TCP/IP）、部分 RISC 处理器（PowerPC、SPARC）、部分文件格式&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>Little Endian&lt;/strong>&lt;/td>
 &lt;td>低位字节存低地址&lt;/td>
 &lt;td>&lt;code>78 56 34 12&lt;/code>&lt;/td>
 &lt;td>x86、ARM 默认模式、Windows/Linux 处理&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://cattle0horse.github.io/posts/csapp/2-representation-and-processing-of-information/attachments/2.%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86-20250321155438902.png" alt="">&lt;/p></description></item><item><title>1.计算机系统漫步</title><link>https://cattle0horse.github.io/posts/csapp/1-computer-system-walk/</link><pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate><guid>https://cattle0horse.github.io/posts/csapp/1-computer-system-walk/</guid><description>&lt;h2 id="1计算机系统漫步">1.计算机系统漫步&lt;/h2>
&lt;p>为什么要了解编译系统是如何工作的？&lt;/p>
&lt;ul>
&lt;li>优化程序性能&lt;/li>
&lt;li>理解链接时出现的错误&lt;/li>
&lt;li>避免安全漏洞&lt;/li>
&lt;/ul>
&lt;h3 id="helloworld-程序的一生简述">HelloWorld 程序的一生简述&lt;/h3>
&lt;p>&lt;img src="https://cattle0horse.github.io/posts/csapp/1-computer-system-walk/attachments/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%AD%A5-20250319131409323.png" alt="">&lt;/p>
&lt;p>一个 C 语言程序（例如 &lt;code>hello.c&lt;/code>）从编写到执行再到结束的整个生命周期&lt;/p>
&lt;ol>
&lt;li>&lt;strong>编译过程&lt;/strong>：
&lt;ul>
&lt;li>C 语言是一种高级语言，计算机无法直接理解。为了让计算机能够执行 C 语言程序，必须将其转换为机器语言。这一过程称为编译。&lt;/li>
&lt;li>编译过程涉及多个步骤：
&lt;ul>
&lt;li>&lt;strong>预处理&lt;/strong>（cpp）：处理源代码中的预处理指令（如 &lt;code>#include&lt;/code> 和 &lt;code>#define&lt;/code>）。生成 &lt;code>hello.i&lt;/code> 文件&lt;/li>
&lt;li>&lt;strong>编译&lt;/strong>（cc1）：将预处理后的代码转换为汇编语言。生成 &lt;code>hello.s&lt;/code> 文件&lt;/li>
&lt;li>&lt;strong>汇编&lt;/strong>（as）：将汇编语言转换为机器语言（目标文件）。生成 &lt;code>hello.o&lt;/code> 文件&lt;/li>
&lt;li>&lt;strong>链接&lt;/strong>（ld）：将目标文件与所需的库文件 (如 &lt;code>printf.o&lt;/code>) 链接，生成最终的可执行文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>程序执行过程&lt;/strong>：
&lt;ul>
&lt;li>当用户在 shell 中运行可执行程序时，shell 会调用 &lt;code>fork&lt;/code> 函数创建一个子进程。&lt;/li>
&lt;li>创建子进程后，操作系统使用 &lt;code>execve&lt;/code> 函数来加载程序的可执行文件，并为其分配虚拟内存。&lt;/li>
&lt;li>程序开始执行，从 &lt;code>main&lt;/code> 函数开始，执行相关代码（例如打印信息）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>运行优化&lt;/strong>：
&lt;ul>
&lt;li>在程序运行过程中，操作系统使用多种机制（如 TLB、页表、缓存等）来提高程序的执行效率。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>程序结束与资源回收&lt;/strong>：
&lt;ul>
&lt;li>程序执行完成后，shell 会回收子进程，操作系统内核会删除与该进程相关的数据结构，并释放占用的资源。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="计算机系统的硬件组成">计算机系统的硬件组成&lt;/h3>
&lt;p>&lt;img src="https://cattle0horse.github.io/posts/csapp/1-computer-system-walk/attachments/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%AD%A5-20250319151147368.png" alt="">&lt;/p>
&lt;p>&lt;strong>CPU(Central Process Unit, 中央处理单元, 处理器)：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Program Count(PC, 程序计数器，指令指针)&lt;/strong>：大小为一个 word(字) 的存储区域，存放某一条指令的地址
&lt;ul>
&lt;li>CPU 从通电开始就在不断执行 PC 指向的指令，然后更新 PC 使其指向下一条要执行的指令（注意，下一条要执行的指令与刚刚执行的指令并不一定相邻）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Register file(寄存器文件)&lt;/strong>：CPU 中的一个存储设备，由单字长的寄存器组成&lt;/li>
&lt;li>&lt;strong>Register(寄存器)&lt;/strong>：临时存放数据的空间，保存计算结果，每个寄存器有自己唯一的名字&lt;/li>
&lt;li>&lt;strong>ALU(Arithmetic Logic Unit, 算术逻辑单元)&lt;/strong>：复制寄存器中保存的值执行算术运算，并保存到寄存器中
&lt;ul>
&lt;li>以计算两个变量 a+b 的和为例：
&lt;ul>
&lt;li>CPU 进行数据的加载：CPU 从内存中读取 a 的值暂存至寄存器 X 中，读取 B 的至暂存至寄存器 Y 中（这个操作会覆盖寄存器中原来的值）&lt;/li>
&lt;li>ALU 复制寄存器 X 和 Y 中保存的数值，进行算数运算，并保存到寄存器 X 或 Y 中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Main Memory(主存, 内存)&lt;/strong>：CPU 在执行程序时，内存主要存放程序的指令及数据，由 RAM(随机访问存储器) 组成，可以看作一个从 0 开始的数组，每个字节都有相应的地址&lt;/li>
&lt;li>&lt;strong>Bus(总线)&lt;/strong>：负责将信息从一个部件传递到另一个部件，通常总线被设计成传送固定长度的字节块，也就是 word(字)&lt;/li>
&lt;li>&lt;strong>输入输出设备&lt;/strong>：如鼠标、键盘、显示器、磁盘等，通过控制器或适配器与 IO 总线相连。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>对于 字长 (word size) 为 32 位的机器 1word = 4Byte
对于 字长为 64 位的机器 1word = 8Byte&lt;/p></description></item></channel></rss>